# ThreadPool-CPP
## 项目介绍

作为五大池之一（内存池、连接池、线程池、进程池、协程池），线程池的应用非常广泛，不管是客户端程序，还是后台服务程序，都是提高业务处理能力的必备模块。有很多开源的线程池实现，虽然各自接口使用上稍有区别，但是其核心实现原理都是基本相同的。

## 知识背景

熟练基于C++ 11标准的面向对象编程 

组合和继承、继承多态、STL容器、智能指针、函数对象、绑定器、可变参模板编程等。 

熟悉C++11多线程编程

thread、mutex、atomic、condition_variable、unique_lock等。 

熟悉多线程理论 

多线程基本知识、线程互斥、线程同步、原子操作等。

## 并发和并行

- CPU单核（非常少）

- CPU多核 或 多CPU

### 并发

**单核**上，多个线程占用不同的CPU时间片，物理上还是串行执行的，但是由于每个线程占用的CPU时间片非常短（比如10ms），看起来就像是多个线程都在共同执行一样，这样的场景称作并发（**concurrent**）。

### 并行

在多核或者多CPU上，多个线程是在真正的**同时**执行，这样的场景称作并行（**parallel**）。



## 多线程优势

多线程程序一定就好吗？不一定，要看具体的应用场景

①IO密集型

无论是CPU单核、CPU多核、多CPU，都是比较适合多线程程序的

②CPU密集型

单核

**不适合**，多线程存在线程上下文切换，有额外的花销，线程越多上下文切换所花费的额外时间也越多，倒不如一个线程一直进行

CPU多核、多CPU

多个线程可以并行执行，对CPU利用率好



IO密集型永远适合设计成多线程，因为IO操作是可以阻塞程序的，此时CPU空闲了，造成浪费

详见操作系统



## 线程池

### 线程的消耗、数量，越多越好？

为了完成任务，创建很多的线程可以吗？线程真的是越多越好？ 

- 线程的创建和销毁都是非常"重"的操作 

- 线程栈本身占用大量内存



进程->所有线程共享进程的地址空间

线程栈就是创建线程时分配的栈空间

如果是 32 位系统，用户态的虚拟空间只有 3G，如果创建线程时分配的栈空间是 10M，那么一个进程最多只能创建 300 个左右的线程。（ulimit - ？？）

如果是 64 位系统，用户态的虚拟空间大到有 128T，理论上不会受虚拟内存大小的限制，而会受系统的参数或性能限制。

创建了一大批线程，还没有做具体的事情每一个线程都需要线程栈，栈几乎都被占用完了，还怎么做事情?

- 线程的上下文切换要占用大量时间 

过多的线程将会导致大量的CPU时间浪费在线程切换上，CPU利用率不高

- 大量线程同时唤醒会使系统经常出现锯齿状负载或者瞬间负载量很大导致宕机





一些优秀的开源网络库，用几个线程？

C++   muduo libevent 
Java  Netty mina 

一般都是 IO复用 + 多线程      (有几个线程呢?  一般都是按照当前CPU的核心数量来确定的，6核)

### 引出线程池，线程池的优势？

操作系统上创建线程和销毁线程都是很"重"的操作，耗时耗性能都比较多，那么在服务执行的过程中，如果业务量比较大，实时的去创建线程、执行业务、业务完成后销毁线程，那么会导致系统的实时性能降低，业务的处理能力也会降低。 

**线程池的优势就是，在服务进程启动之初，就事先创建好线程池里面的线程，当业务流量到来时需要分配线程，直接从线程池中获取一个空闲线程执行 task 任务即可，task 执行完成后，也不用释放线程，而是把线程归还到线程池中继续给后续的 task 提供服务。**



### fixed模式线程池

线程池里面的线程个数是固定不变的，一般是 ThreadPool 创建时根据当前机器的 CPU 核心数量进行指定。

### cached模式线程池

线程池里面的线程个数是可动态增长的，根据任务的数量动态的增加线程的数量，但是会设置一个线程数量的阈值（线程过多是有坏处的），任务处理完成，如果动态增长的线程空闲了60秒还没有处理其它任务，那么关闭线程（释放掉），保持池中最初数量的线程即可。



## 代码设计

详见 threadpool.h

有关 CMake 使用详见👉[shayudiandian/Linux-CPP-development-environment: Linux C/C++ 开发环境教程](https://github.com/shayudiandian/Linux-CPP-development-environment)



## 使用示例

只需在自己的文件导入头文件即可

```c++
#include "threadpool.h"
...
ThreadPool pool;   // 创建线程池
pool.setMode(PoolMode::MODE_CACHED);  // 线程池模式
pool.start(2);    // 线程池线程数量
```

假设有一个耗时任务 int sum(int, int, int);

```C++
int sum(int a, int b, int c) {
    this_thread::sleep_for(chrono::seconds(2));    // 模拟耗时
    return a + b + c;
}
```

提交线程池任务

```C++
// 提交线程池任务
future<int> r1 = pool.submitTask(sum, 1, 2, 3);
future<int> r2 = pool.submitTask([](int b, int e)->int {
            int sum = 0;
            for (int i = b; i <= e; i++) sum += i;
            return sum;
        }, 1, 100);
...
// 获取结果
cout << r1.get() << endl;
cout << r2.get() << endl;
```

